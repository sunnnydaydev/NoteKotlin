# 泛型

# 一、介绍
语法与java一样，这里简单介绍下~

```kotlin
class Generic<T> // class 类名<类型参数>
```
一般来说，要创建这样类的实例，我们需要为类型参数提供实际类型

```kotlin
class Generic<T>

fun main(){
    //这里Int就是类型参数的实际类型
    val generic = Generic<Int>()
}
```

但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数：

```kotlin
class Generic<T>(t:T)
class Dog

fun main(){
    val generic1 = Generic(1)
    val generic2 = Generic("1")
    val generic3 = Generic(Dog())
}
```
# 二、Java泛型通配符回顾

什么 Java 需要那些神秘的通配符？在 《Effective Java》第三版 解释了该问题——第 31 条：利用有限制通配符来提升 API 的灵活性。

灵活性的具体体现在哪呢？我们不妨先看个例子:

```java
public class GenericTest1 {
    public static void main(String[] args) {
        List<String> strs = new ArrayList<>();
        //此处的编译器错误让我们避免了之后的运行时异常
        List<Object> objs = strs; 
        // 假如上述代码编译器不报错，我们继续执行如下的代码则会在运行期间报错。
        objs.add(1); 
        String s = strs.get(0); //ClassCastException：无法将整数转换为字符串，二者不存在继承关系。
    }
}
```
通过上面栗子我们可以知道List<Object>并不是List<String>的父类，java禁止🈲上述操作保证了运行时的安全。但这会有一些影响，如在设计Collection#addAll
方法时我们直觉上可能会这样设计：

```java
interface Collection<E>{
  void addAll(Collection<E> items);
}
```
上述在安全性上是没有毛病的，但我们无法做到如下功能：

```java
interface Collection<E>{
  void addAll(Collection<E> items);
  /**
   * 对于这种简单声明的 addAll 将不能编译：Collection<String> 不是 Collection<Object> 的子类型
   * */
  void copyAll(Collection<Object> to, Collection<String> from) {
        to.addAll(from);
    }
}
```

因此为了提升java api的灵活性，引入通配符与上下边界的概念，这就是为啥addAll() 实际设计为以下这样：

```java
interface Collection<E>{
  void addAll(Collection<? extends E> items);
}
```
通配符类型参数 ? extends E 表示此方法接受 E 或者 E 的 一些子类型对象的集合，而不只是 E 自身。 这意味着我们可以安全地从其中（该集合中的元素是 E 的子类的实例）
读取 E，但不能写入， 因为我们不知道什么对象符合那个未知的 E 的子类型。

该限制可以让Collection<String>表示为Collection<? extends Object>的子类型

