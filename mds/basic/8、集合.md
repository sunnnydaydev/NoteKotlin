# 集合

## 概述

kotlin的集合和java的稍微有些区别，java中声明一个集合后边可轻松实现增删操作，kotlin便不是这样，kotlin中分为可变集合、不可变集合。

kotlin中 List、Set、Map接口都是不可变的这意味着我们对集合只有读的权限无写的权限，想要有写的权限就要 声明 或 转为 可变集合。

List、Set、Map都类似，这里就以List举个例子

```kotlin
fun main() {

    val list4 = listOf("1", "2") //listOf为不可变集合
    val list1 = arrayListOf("1")  // ArrayList可变集合

    val list2: List<String> = list1// 转为List接口后不可变。list2 不具有 add remove操作
    val list3: MutableList<String> = list2 as MutableList<String>// 转为MutableList接口后可变

}
```

可见想要转换只需要依赖List和MutableList接口就行啦。

# 创建集合

通过系统提供的标准库能帮助我们快速创建集合

- listOf<T>()
- setOf<T>()
- mutableListOf<T>()
- mutableSetOf<T>()
- mapOf<K,V>()
- mutableMapOf<K,V>()

- emptyList()
- emptySet()
- emptyMap()

```kotlin
fun main() {
    val listOf1 = listOf<String>()
    val listOf2 = listOf("1", "2")

    val set = setOf("1", "2")
    val mutableListOf = mutableListOf("1", "2")
    val mutableSetOf = mutableSetOf("1", "2")

    val pair1 = Pair(first = "name", second = "Carry")
    val pair2 = Pair(first = "name", second = "Carry")
    val mapOf1 = mapOf(pair1, pair2)
    val mapOf2 = mapOf("name" to "Carry")
    val mutableMapOf = mutableMapOf("name" to "Carry")
    val mutableMapOf1 = mutableMapOf<String, String>().apply {
        this["name"] = "Carry"
    }

    val emptyList = emptyList<String>()
    val emptySet = emptySet<String>()
    val emptyMap = emptyMap<String, String>()


    val arrayList = arrayListOf("1", "2")
    val arrayList2 = arrayListOf<Int>() // empty arrayList
}
```

注意几点：

- 以逗号分隔的集合元素列表作为参数，编译器会自动检测元素类型。
- 创建空集合时，须明确指定类型。
- map中存的是Pair对象，通常使用中缀函数 to 创建。to 符号创建了一个短时存活的 Pair 对象，因此建议仅在性能不重要时才使用它。 为避免过多的内存
  使用，请使用其他方法。如借助apply函数。

# 集合的复制

要创建与现有集合具有相同元素的集合，可以使用复制操作。标准库中的集合复制操作创建了具有相同元素引用的 浅 复制集合。 因此，对集合元素所做的更改会
反映在其所有副本中。

在特定时刻通过集合复制函数，例如toList()、toMutableList()、toSet() 等等。创建了集合的快照。 结果是创建了一个具有相同元素的新集合 如果在源
集合中添加或删除元素，则不会影响副本。副本也可以独立于源集合进行更改。

```kotlin
fun main() {
    val mutableListOf = mutableListOf("init")
    val toList = mutableListOf.toMutableList()

    /**
     * 验证内存地址一致
     * listOf1:3237167
     * toList:3237167
     * */
    println("listOf1:${mutableListOf.hashCode()}")
    println("toList:${toList.hashCode()}")

    /**
     * 验证使用kt类库提供的api创建的副本，针对副本操作不会影响源集合
     * mutableListOf:init、mutableListOf:1
     * toList:init、toList:2
     * */
    mutableListOf.add("1")
    toList.add("2")
    mutableListOf.forEach {
        println("mutableListOf:${it}")
    }
    toList.forEach {
        println("toList:${it}")
    }

    /**
     * 验证原始的引用赋值方式创建的副本针对副本修改会影响源集合
     * mutableListOf1:init、mutableListOf1:1
     * */
    val mutableListOf1 = mutableListOf("init")
    val mutableListOf2 = mutableListOf1
    mutableListOf2.add("1")
    mutableListOf1.forEach {
        println("mutableListOf1:${it}")
    }

}
```

# 集合的迭代

Iterator是基类接口，定义了如下规范：

```kotlin
public interface Iterator<out T> {
    /**
     * 获取当前元素，并将指针指向下一元素。
     * */
    public operator fun next(): T

    /**
     * 是否存在下一个元素
     * */
    public operator fun hasNext(): Boolean
}
```

ListIterator 扩展了基类支持列表的双向迭代：

```kotlin
public interface ListIterator<out T> : Iterator<T> {
    // Query Operations
    override fun next(): T
    override fun hasNext(): Boolean

    /**
     * Returns `true` if there are elements in the iteration before the current element.
     */
    public fun hasPrevious(): Boolean

    /**
     * Returns the previous element in the iteration and moves the cursor position backwards.
     */
    public fun previous(): T

    /**
     * Returns the index of the element that would be returned by a subsequent call to [next].
     */
    public fun nextIndex(): Int

    /**
     * Returns the index of the element that would be returned by a subsequent call to [previous].
     */
    public fun previousIndex(): Int
}
```
MutableIterator扩展了Iterator可以在迭代时增、删、更新元素：

```kotlin
public interface MutableListIterator<T> : ListIterator<T>, MutableIterator<T> {
    // Query Operations
    override fun next(): T
    override fun hasNext(): Boolean

    // Modification Operations
    override fun remove(): Unit

    /**
     * Replaces the last element returned by [next] or [previous] with the specified element [element].
     */
    public fun set(element: T): Unit

    /**
     * 当前元素之前插入新的元素。
     */
    public fun add(element: T): Unit
}
```

如何获取可变集合迭代器呢？很简单可变集合直接调用api即可。

```kotlin
    val iterableList  =  listOf("1","2","3")
    val  iterator = iterableList.toMutableList().listIterator()
```

```kotlin
    val iterableList  =  listOf("1","2","3")
    val  iterator = iterableList.toMutableList().listIterator()
     iterator.next() //默认当前元素为首个元素，调用next后当前元素指向"2"
     iterator.add("test") // 此时集合为"1","test"，"2","3",当前元素还是指向"2"
     println("current:${iterator.next()}") //此时应打印"2",然后当前元素指向3

log ->
current:2
```

# 序列

回顾下集合的map操作，其实map是Iterable的一个扩展函数 ->

```kotlin
public inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
}
```

序列Sequence<T>提供了与Iterable<T>相同的函数，但实现另一种方法来进行 多步骤 集合处理。


###### 1、序列的创建

（1）通过api sequenceOf

（2）通过Iterable（List或set）对象的api asSequence

（3）generateSequence api

（4）sequence{}

后两种创建方式使用较少，可以查阅官方文档了解下~

###### 2、序列与集合的区别

集合执行一些列操作时：会依次执行每个步骤同时获取到步骤执行的中间结果集合，在此集合上继续执行后续步骤。

序列执行一系列操作时：序列会对每一个元素逐个执行所有处理步骤。

可见序列可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。 但是，序列的延迟性质增加了一些开销，这些开销在处理较小的集合或进行更简单的计算
时可能很重要。 因此，应该同时考虑使用 Sequence 与 Iterable，并确定在哪种情况更适合。

栗子 🌰

假定有一个单词列表。要求过滤长度大于3个字符的单词，并打印前四个单词的长度。

使用集合我们会这样做：

```kotlin
//1、字符串转list
val words = "The quick brown fox jumps over the lazy dog".split(" ")

//2、集合操作依次执行
val lengthsList = words.filter {
    it.length > 3 // 长度大于3的筛选出来，结果是一个子集合。
}
    .map {
        it.length // string 集合转为 int集合
    }
    .take(4) //取int集合元素前4个
println("Lengths of first 4 words longer than 3 chars:")
println(lengthsList)
```

![序列](https://gitee.com/sunnnydaydev/my-pictures/raw/master/github/kt/Iterable.png)

使用序列我们会这样做：

```kotlin
// 1、字符串转集合
val words = "The quick brown fox jumps over the lazy dog".split(" ")
// 2、集合转换为序列
val wordsSequence = words.asSequence()

// 3、同样的操作，不过每个元素依次执行下列操作。
val lengthsSequence = wordsSequence.filter {
    it.length > 3
}
    .map {
        it.length
    }
    .take(4)

println("Lengths of first 4 words longer than 3 chars")
// 末端操作：获取结果。
println(lengthsSequence.toList())
```

![序列](https://gitee.com/sunnnydaydev/my-pictures/raw/master/github/kt/Sequence.png)

###### 3、序列与异步流区别？

序列是同步计算，异步流（Flow）是异步计算。

###### 4、序列注意点

如果序列操作返回延迟生成的另一个序列，则称为 中间序列。如调用了toList()。

没有生成新的序列则最后的操作叫末端操作，如 map、filter、take、drop等。只能通过末端操作才能检索序列元素。

# The end

更多集合操作可参考这里

[集合操作概述](https://www.kotlincn.net/docs/reference/collection-operations.html)




