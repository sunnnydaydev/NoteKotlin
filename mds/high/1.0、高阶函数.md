### 一、高阶函数

> kotlin中除了Int、Number、String等常见的数据类型之外又加入了一种新的数据类型即函数类型。kotlin中每个函数都有特定的函数类型。

###### 1、kotlin的函数

kotlin的函数看着才像标准的"输入输出"函数，因为输入在前输出在后，看个普通函数的🌰

```kotlin
fun sum(num1: Int, num2: Int): Int {
    return num1 + num2
}
```

如上,函数的参数就是输入，返回值类型就是输出。参数在前返回值在后这就是标准的输入输出思想。

为啥先讲下这个呢？因为我感觉了解了标准输入输出思想有助于我们对函数类型的理解~

###### 2、函数类型🌰

```kotlin
fun getString(n: Int): Int {}
```

如上就是一个普通的kotlin方法，其函数类型为（Int）->Int。我们可以把函数类型看做与Int、String等同等级的一种新的类型。函数类型的语法表示如下：

```kotlin
(参数类型)->返回值类型
```

可以看到高阶函数也是标准的输入输出函数:小括号内就是"输入",返回值类型就是"输出"。

因此针对任意一个方法我们都能说出其函数类型：

```kotlin
   //(String)->Unit
fun test1(name: String) {}

//(String)->String
fun test2(name: String): String {
    return ""
}

//(String,Int)->Long
fun test3(name: String, age: Int): Long {
    return 3L
}

//(String,List<String>)->Int
fun test4(name: String, list: List<String>): Int {
    return 3L
}
```

###### 3、函数类型的作用

既然函数类型与String、Int、Byte等类型并列为kotlin中的数据类型，那么函数类型同样具备如下功能：

- 作为变量使用（成员或局部）
- 作为形参使用
- 作为方法返回值使用

###### 4、函数类型的定义赋值使用

（1）定义

函数类型变量的定义也是类似标准的"输入输出"方式定义，看个🌰

```kotlin
fun main() {
    val methodAction: () -> String
}
```

先看下这段代码代表的意思：定义个函数类型的变量methodAction。methodAction就是变量名，变量类型为() -> String

（2）赋值

常见的赋值方式有两种，一种是先定义变量，然后对变量进行赋值：

```kotlin
    val methodAction: () -> String
methodAction = {
    "返回值"
}
```

另一种是定义变量时直接赋值：

```kotlin
    val methodAction: () -> String = {
    "返回值"
}
```

这个感觉和kt的这种方法类似:右面的结果就是左面类型返回值

```kotlin
//完整写法fun sum(num1: Int, num2: Int):Int = num1 + num2
fun sum(num1: Int, num2: Int) = num1 + num2
```

其实右面的{} 还有个名字叫lambda表达式（无函数名的高阶函数），就是没有名字的高阶函数。常见的有如下几种：

```kotlin
//1、无参数，返回值类型为Unit的匿名函数
{}
//2、有参数，返回值类型为String的匿名函数
{
    "我是返回值"
}
//3、有参数，返回值类型为String的匿名函数
{ name:String ->
    "我是返回值:$name"
}
```
- {}的函数类型为 ()->Unit
- {"我是返回值"}的函数类型为 ()->String
- { name:String ->"我是返回值:$name"}的函数类型为 (String)->String

到这里应该明白🌰栗子中高阶函数左右的对等关系了吧

```kotlin
    val methodAction: () -> String = { "返回值" }
```

（3）使用

使用就很简单啦，常见的有两种调用方式

```kotlin
    val methodAction: () -> String = {
      "返回值"
    }
    //两种使用高阶函数方式:
    methodAction.invoke()
    methodAction()
```

###### 5、高阶函数的使用

（1）栗子🌰

```kotlin
class MainActivity {
    //模拟onCreate
    fun onCreate() {
        ItemAdapter(::onViewClick)
    }

    private fun onViewClick(id:Int){
        println("你点击了id")
    }
}

class ItemAdapter(private val onItemClick: (id: Int) -> Unit = {}) {
    //模拟View渲染完成
    fun onViewUpdate(id: Int) {
        onItemClick.invoke(id)//或者onItemClick(id)
    }
}
```
一个Android中常见的例子，RecyclerView的点击事件回调，使用高阶函数完全可以做到，代替了接口回调。上面有两点需要注意

- val onItemClick: (id: Int) -> Unit = {} 这里{}中隐含个变量it,完整写法是这样的val onItemClick: (id: Int) -> Unit = {it->}
假如等号高阶函数有一个参数lambda表达式默认参数为it可省略不写。
- lambda表达是是有返回值的，返回值默认为表达式的最后一行语句
- 注意这里有一个新的操作符::这个操作符带上函数名就代表把普通函数当做其函数类型引用

(2)栗子🌰

还是上述例子，不用::还有种写法

```kotlin
class MainActivity {
    fun onCreate() {
        ItemAdapter().apply {
            onItemClick = {
                println("你点击了$it")
            }
        }
    }
}

class ItemAdapter {
    var onItemClick: (id: Int) -> Unit = {}
    fun onViewUpdate(id: Int) {
        onItemClick.invoke(id)
    }
}
```

（3）栗子🌰

 定义个高阶函数，根据传入的函数类型决定求两数之和还是两数之差

```kotlin

fun test(num1: Int, num2: Int, fun1: (Int, Int) -> Int) {
    val result = fun1(num1, num2) 
    println(result)
}

//求和普通函数
fun plus(num1: Int, num2: Int): Int {
    return num1 + num2
}
//求差普通函数
fun minus(num1: Int, num2: Int): Int {
    return num1 - num2
}
```

```kotlin
fun main() {
    // 这里第3个参数传递其他函数时，结果可能不同:
    println(test(10, 5, ::plus))//15
    println(test(10, 5, ::min))//5
}
```

# 二、匿名高阶函数lambda表达式

Lambda 本质是一种匿名函数，作为表达式它的运行结果可以作为表达式、形参、和函数返回值。语法如下:

```kotlin
{参数:参数类型-> Lambda表达式体}
```

###### 1、lambda有如下规则

- 定义 Lambda 表达式作为一个方法，不需要 fun 关键字，也无须指定方法名
- 如果lambda表达式有形参列表，参数要放在 -> 左面，参数类型可以省略。
- lambda函数体放在 -> 右面
- 函数的最后一个表达式默认为 Lambda 的返回值，且无须 return 关键字

###### 2、kotlin中的lambda规定
这里就以kotlin的标准函数let函数来举个栗子来介绍下三条规定。

```kotlin
// 语法(student为任意对象，任意对象都有这个let方法)
student?.let {
    //todo code.
}

/**
初次见这个东西可能会看不懂，其实代码是这样变换来的，完整写法：
 */
student?.let({// lambda 表达式作为方法参数
        it: Student ->
    // todo code
})
/**
可见let()方法需要一个参数，这个参数是一个lambda表达式。

kotlin中规定1：当lambda表达式是函数的最后一个参数时，可将lambda表达式移动到括号外面。
代码进行变换：
 */
student?.let() { it: Student ->
}
/**
kotlin中规定2：如果lambda表达式是函数的“唯一”参数，还可以将函数的括号省略。
代码再次进行变换：
 */
student?.let { it: Student ->
}
/**
kotlin中规定3：当“lambda表达式”的参数列表中只有一个参数时，也不必声明参数名，可以使用it关键字代替。

代码再次变换：
 */
student?.let {
}
/**
经过上面的几步变换后基本很精简了
 */

```

